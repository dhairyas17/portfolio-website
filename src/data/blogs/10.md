### Why Database Choice Is a Product Decision

As a Technical Product Manager, I have learned that choosing a database is as much a product decision as a technical one. The wrong choice can slow development, fail under scale, and force expensive migrations. 

The right choice aligns with the data model, matches consistency and availability needs, and scales with the roadmap. This is the framework I use to make that call.

### Start With the Data Shape and Access Patterns

Before picking a database, understand the shape of your data and how it will be accessed.

- Tabular and transactional → relational database
- Flexible schema with nested documents → document store
- Time-series metrics → time-series database

Being explicit about reads, writes, joins, and aggregation patterns will narrow your options fast.

### Decide on Transactional Integrity or Availability

Do you need strong consistency or is eventual consistency acceptable?

Relational databases like PostgreSQL and MySQL are best when:
- Strong consistency is required
- Schema enforcement matters
- Multi-table transactions are common

NoSQL systems like MongoDB, Cassandra, or DynamoDB work when:
- Scalability and availability are top priorities
- Eventual consistency is acceptable
- High write throughput is needed

### Factor in Read and Write Load

Some workloads are write-heavy, others are dominated by reads.  
Think about how this changes as you grow.

- Write-heavy → DynamoDB, Cassandra, Kafka + storage layer
- Read-heavy with global traffic → caches, read replicas, or globally distributed databases like CockroachDB

Design for the next 10x scale, not just today.

### Be Honest About Operational Complexity

Who will run the database?

- Self-hosted PostgreSQL gives control but requires operational maturity
- Managed services like DynamoDB, MongoDB Atlas, or PlanetScale reduce ops overhead but increase dependency on the provider

Early-stage products often benefit from managed services to ship faster.

### Separate Analytics From Transactions

Trying to run analytics on your transactional database slows both down.

- OLTP: PostgreSQL, MySQL
- OLAP: BigQuery, Snowflake, ClickHouse
- Use ETL tools like dbt, Airbyte, or Apache NiFi to move data between them

### Rules of Thumb

- Default to PostgreSQL unless you have a clear reason not to
- Avoid sharding early — scale up or add replicas first
- For MVPs, choose managed databases that minimize setup and maintenance

### Quick Reference

![Move Right Icon](/assets/table/11-table.png)

### Closing Thought

Database choice will change with your product. What works at MVP may fail at scale, and what scales elegantly may slow development.  

**Choose for today, design for tomorrow.**
